# name: test/sql/chess_moves_hash.test
# description: Test chess_moves_hash scalar function (Spec: move-analysis - Moves Hashing)
# group: [chess_moves_hash]

require chess

# Test hash consistency - identical moves with different formatting
query I
SELECT (chess_moves_hash('1. e4 e5') = chess_moves_hash('1.e4 e5'))::BOOLEAN;
----
true

# Test hash consistency - identical moves with comments
query I
SELECT (chess_moves_hash('1. e4 {comment} e5') = chess_moves_hash('1. e4 e5'))::BOOLEAN;
----
true

# Test hash consistency - identical moves with variations
query I
SELECT (chess_moves_hash('1. e4 (1. d4) e5') = chess_moves_hash('1. e4 e5'))::BOOLEAN;
----
true

# Test hash consistency - identical moves with NAGs
query I
SELECT (chess_moves_hash('1. e4! e5?') = chess_moves_hash('1. e4 e5'))::BOOLEAN;
----
true

# Test hash discrimination - different moves produce different hashes
query I
SELECT (chess_moves_hash('1. e4 e5') != chess_moves_hash('1. d4 d5'))::BOOLEAN;
----
true

# Test hash discrimination - different length sequences
query I
SELECT (chess_moves_hash('1. e4') != chess_moves_hash('1. e4 e5'))::BOOLEAN;
----
true

# Test transposition collision - different move order, same final position
query I
SELECT (chess_moves_hash('1. Nf3 d5 2. g3') = chess_moves_hash('1. g3 d5 2. Nf3'))::BOOLEAN;
----
true

# Test empty input returns NULL
query I
SELECT chess_moves_hash('') IS NULL;
----
true

# Test NULL input propagates NULL
query I
SELECT chess_moves_hash(NULL) IS NULL;
----
true

# Test hash returns UBIGINT
query I
SELECT typeof(chess_moves_hash('1. e4 e5'));
----
UBIGINT

# Test deduplication use case - find duplicates
statement ok
CREATE TABLE games AS SELECT * FROM (VALUES
    ('1. e4 e5 2. Nf3', 'Game 1'),
    ('1.e4 e5 2.Nf3', 'Game 2'),
    ('1. e4 {best} e5 2. Nf3', 'Game 3'),
    ('1. d4 d5', 'Game 4')
) AS t(movetext, name);

query I
SELECT MAX(count)
FROM (
  SELECT COUNT(*) as count
  FROM games
  GROUP BY chess_moves_hash(movetext)
  HAVING COUNT(*) > 1
) t;
----
3
